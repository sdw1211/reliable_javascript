# 챕터 1 : 좋은 소프트웨어 만들기

* 자바스크립트 함수는 다른 함수 내부에 충접해서 사용가능, 스코프를 다스리는 중요한 수단
* 자바스크립트 함수가 일급 객체이다.
  * 일급객체란 인자로 전달, 함수로 반환, 변수로 할당 자료구조로 저장할 수 있다는 의미
  ```javascript
  var aaa = function() {}; //변수로 할당
  var bbb = function(func) {return function() {}};  //결과로 반환
  bbb(aaa) //인자로 전달
  ...
  ```
* 자바스크립트에 오버로딩 개념은 함수의 arguments를 보고 여기에 웜가 맞추는 행위
  ```javascript
  line.x = function(funcToGetX) {
      if (arguments.length) return getX;
      getX = funcToGetX;
      return line;
  }
  ```

* 덕타이핑
  * 생성자 함수로 객체를 만들어서 사용하는 방식
  * 오리처럼 생겨서 오리처럼 걷고 오리처럼 꽥꽥 소리를 낸다면 그건 오리다.라는 속담에서 유래
  ```javascript
  function XYPair(x,y) {
      this.x = x;
      this.y = y;
  }

  var objectData = [
      new XYPair(10,130),
      new XYPair(100,60),
      new XYPair(190,160),
      new XYPair(280,10)
  ];

  //판별
  if (something instanceof XYPair)
  //그런데 이게 자바스크립트에서는 과연 필요할까?
  //자바스크립트는 다른 자바나 c#과 같이 명시적인 데이터 타입이 아니기 때문에 굳이 위와 같이 판별할 필요는 없음
  //그래서 x,y의 프로퍼티가 존재하는 여부만 체크하면 된다. 
  if ('x' in something)
  if (something.hasOwnProperty('x'))
  ```
* 클로저,this 다 중요하다! 제대로 알자
* this는 함수를 호출한 객체를 참조한다!!
* 자바스크립트는 싱글 스레드로 움직인다.
  * 이떤 이벤트가 끝나자마자 실행할 함수를 큐에 넣는다.
  * https://developer.mozilla.org/ko/docs/Web/JavaScript/EventLoop
  ```javascript
  function a() {
      for (var i=0; i < 10000000; i++) {

      }

      console.log(100);
  }

  function b() {
      console.log(200);
  }

  setTimeout(b, 0);
  a();

  //출력순서는 100,200
  ```
* 자바스크립트 모듈이 아니다. 
  * 예전에는 스크립트 파일을 하나만 사용했지면 요즘은 여러 스크립트 파일을 다 같이 사용하고 있다.
  * 자바스크립트를 캡슐화한 모듈로 만들어서 써야한다!
* 스코프틑 중첩 함수로 다스린다.
* 규약을 지켜서 코딩을 하자!

## 소프트웨어 공학 원칙

### SOLID 원칙
* 마이클 페더스가 1990년대 후반, 로버트 마틴이 확립한 다음 다섯 가지 객체 지향 설계 원칙을 잘 기억하려고 짜낸 머리글자
  1. Single Responsibility Principle(단일 책임의 원칙)
  2. Open/Closed Principle(개방/폐쇄 원칙)
  3. Liskov Substitution Principle(리스코브 치환 원칙)
  4. Interface Segregation Principle(인터페이스 분리 원칙)
  5. Dependency Inversion Principle(의존성 역전 원칙)

#### 단일 책임의 원칙
* 모든 클래스(자바스크립트는 함수)는 반드시 한 가지 변경 사유가 있어야 한다.
* 특정 관심사를 어떻게 이행할지는 철저하게 외부에게 제공한 함수에 의해 수행하고, 자바스크립트 함수는 관련된 일만하는 방식
* seperation of cencerns : https://gamecodingschool.org/2015/05/29/%EA%B4%80%EC%8B%AC%EC%82%AC%EC%9D%98-%EB%B6%84%EB%A6%ACseparation-of-concerns/

### 개방/폐쇄 원칙
* 모든 개체는 확장 가능성은 열어 두되 수정 가능성은 닫아야 한다는 원칙
* 버그에 의한 실행 코드 수정을 제외하고는 실행 코드를 수정하지 않고, 상속 등의 방법을 이용한 재사용하고 확장하라는 의미
* 어떤 프로그램도 100% 완벽하게 실행 코드를 수정하지 않을 수 없음
* 개발자는 통찰력을 이용하여 이 코드가 앞으로 변경될 일이 없는 부분과 변경일 될 부분을 나눠서 선택해서 진행을 해야 한다.

#### 리스코브 치환 원칙
* 어떤 타입에서 파생된 타입의 객체가 있다면 이 타입을 사용하는 코드는 변경하지 말하야 한다.
* 한 객체를 다른 객체에서 파생하더라도 그 기본 로직이 변경되어서는 안 된다는 뜻

#### 인터페이스 분리 원칙
* 어떤 객체의 사용자에게 그 사용자한테 필요한 메소드만 있는 인터페이스 제공해라.
* 이 책 뒤에 좀 더 자세하게 나온다고 한다.(나중에 보자.)

#### 의존성 역전 원칙
* 상위 수준의 모듈은 하위 수준 모듈에 의존해서는 안 되며 이 둘은 추상화에 의존해야 한다.

### DRY 원칙
* Don't Repeat Yourself
* 모든 지식 조각은 딱 한 번만 나와야 한다는 의미


## 바르게 유지되는 코드 작성

### 단위테스트
* 단위 테스트는 미래를 위한 투자
* 준비, 실행, 단언의 패턴이 있음
  1. 준비 : 단위를 실행할 조건을 확실히 정하고, 의존성 및 함수 입력 데이터를 설정한다.
  2. 실행 : 단위가 함수면 준비 단계에서 미리 설정한 입력값을 함수에 넘겨 실행
  3. 단언 : 미리 정한 조건에 따라 예상대로 단위가 작동하는지 확인
### 테스트 주도 개발
* TDD 개발 단계
  1. 완벽히 변경하면 성공하나 그렇게 되기 전까지는 반드시 실패하는 단위 테스트를 작성
  2. 테스트가 성공할 수 있을 만큼만 '최소한으로' 코딩
  3. 애플리케이션 코드를 리팩토링하며 중복을 제거
* 테스트를 먼저 만든다는 것이 중요 포인트
### 테스트하기 쉬운 코드
* 한 코드에 너무 많은 테스트가 있으면 관리하기 힘들다.
* 각각의 관심사를 줄여서 테스트 수를 줄여서 테스트하기 쉬운 코드로 만들자.
